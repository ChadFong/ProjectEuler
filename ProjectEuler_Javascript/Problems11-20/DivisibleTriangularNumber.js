// The sequence of triangle numbers is generated by adding the natural numbers. 
// So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

// Let us list the factors of the first seven triangle numbers:

// nth - n * (n/2 + 0.5) - result
// 1st - 1 * 1 - 1 : 1
// 2nd - 2 * 1.5 - 3: 1,3
// 3rd - 3 * 2 - 6: 1,2,3,6
// 4th - 4 * 2.5 - 10: 1,2,5,10
// 5th - 5 * 3 - 15: 1,3,5,15
// 6th - 6 * 3.5 - 21: 1,3,7,21
// 7th - 7 * 4 - 28: 1,2,4,7,14,28
// We can see that 28 is the first triangle number to have over five divisors.

// What is the value of the first triangle number to have over five hundred divisors?


// The notes added to the initial example show that the nth triangular number can be calculated as:
// n * (n/2 + 0.5), which will allow us to calculate triangular numbers faster than iteration.
// I confirmed this by running having both iterative and this calculative approach compared in the 
// function, and running it in a while loop.
var nthTriangularNumber = function (nth) {
  return nth * (nth/2 + 0.5);
};

// Our divisor count starts at 2 because every number is divisible by itself and 1.
// We then iterate over every divisor between n/2 (the largest possible number that can be divided into it)
// and √n incrementing by 2.  (Each divisor found between n/2 and √n will have a partner between √n and 1).
var divisibleTriangularNumber = function (desiredDivisorCount) {
  var divisorCount = 2;
  var n = 1, triN;
  while(divisorCount < desiredDivisorCount){
    n++;
    divisorCount = 2;
    triN = nthTriangularNumber(n);
    for(var i = Math.floor(triN/2) ; i > Math.floor(Math.sqrt(triN)) + 1 ; i--) {
      divisorCount = triN % i === 0 ? divisorCount + 2 : divisorCount;
    }
    divisorCount = Math.sqrt(triN) % 1 === 0 ? divisorCount + 1 : divisorCount;
    console.log("n: " + n + " triangle: " + triN + " and divisors: " + divisorCount);
  }
  return triN;
};

